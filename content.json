{"meta":{"title":"磊の博客","subtitle":"每天成长一点!","description":"知止而后有定，定而后能静，静而后能安，安而后能虑，虑而后能得。","author":"yuanlei","url":"https://yuanleiuestc.github.io"},"pages":[],"posts":[{"title":"","slug":"设计模式学习笔记","date":"2018-02-22T00:44:58.430Z","updated":"2018-02-22T04:03:58.000Z","comments":true,"path":"2018/02/22/设计模式学习笔记/","link":"","permalink":"https://yuanleiuestc.github.io/2018/02/22/设计模式学习笔记/","excerpt":"","text":"设计模式创建型模式：工厂模式，抽象工厂模式，单例模式，构建者模式，原型模式。 1 工厂模式:普通工厂模式：定义：建立一个工厂类，实现了同一接口的一些类的实例创建。通过传递不同的字符标识，返回不同的类。 多个工厂方法模式： 对普通工程模式进行改进，通过调用不同的方法名，实现对不同类的创建。 静态工厂方法模式： 将创建类的方法加static关键字，从而不需要创建实例，直接调用方法，实现类的创建。 2 抽象工厂模式 类的创建依赖与工厂类，如果想要扩展，则需要对工厂类进行修改，违背了闭包原则。 写一个抽象工厂类， 3.单例模式保证在一个JVM中，该对象只存在一个实例。 定义：一个类只有一个实例。1234567891011 public class Singleton &#123; private static class Holder &#123; private static Singleton singleton = new Singleton(); &#125; private Singleton()&#123;&#125; public static Singleton getSingleton()&#123; return Holder.singleton; &#125;&#125; 123456789public enum Singleton &#123; INSTANCE； private String name; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125; 4.建造者模式定义：是将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 建造者模式的使用场景： （1）当产品有复杂的内部构造时（参数很多）。（2）需要生产的产品的属性相互依赖，这些属性的赋值顺序比较重要时（因为在调用ConcreteBuilder的赋值方法时是有先后顺序的）。 5.原型模式 原型模式：使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。原型模式的适用环境： 1：创建新对象成本较大（例如初始化时间长，占用CPU多或占太多网络资源），新对象可以通过复制已有对象来获得，如果相似对象，则可以对其成员变量稍作修改。 2：系统要保存对象的状态，而对象的状态很小。 3：需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的组合状态，通过复制原型对象得到新实例可以比使用构造函数创建一个新实例更加方便。 结构型模式 6适配器模式定义：将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。 类适配器模式：继承目标类，并实现目标接口。 // 已存在的、具有特殊功能，但不符合我们既有的标准接口的类 class Adaptee { public void specificRequest() { System.out.println(\"被适配的类，该类具有特殊功能\"); } } // 目标接口 interface Target { public void request(); } // 具体目标类，只提供普通功能 class ConcreteTarget implements Target { public void request() { System.out.println(\"普通类，该类具有普通功能\"); } } // 适配器类，继承了被适配类，同时实现标准接口 class Adapter extends Adaptee implements Target{ public void request() { super.specificRequest(); } } //测试类 // 使用普通功能类 Target concreteTarget = new ConcreteTarget(); concreteTarget.request(); //输出“普通类，该类具有普通功能” // 使用特殊功能类，即适配类 Target adapter = new Adapter(); adapter.request(); //输出“被适配的类，该类具有特殊功能” 对象适配器模式：只实现标准接口，再在内部维护被适配类的引用的方式。接口适配器：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可","categories":[],"tags":[]},{"title":"","slug":"java学习笔记 异常处理","date":"2018-01-17T03:11:58.220Z","updated":"2018-02-22T00:44:24.000Z","comments":true,"path":"2018/01/17/java学习笔记 异常处理/","link":"","permalink":"https://yuanleiuestc.github.io/2018/01/17/java学习笔记 异常处理/","excerpt":"","text":"异常1234try&#123;&#125;catch()&#123;&#125; #String String是不可变的，每次都会复制一个新的副本。String StringBuilder StringBuffer对于三者使用的总结： 1.如果要操作少量的数据用 = String 2.单线程操作字符串缓冲区 下操作大量数据 = StringBuilder 3.多线程操作字符串缓冲区 下操作大量数据 = StringBuffer 字符串的格式化输出String.format(); 正则表达式a.split(regex); a.replaceAll(regex, replacement); a.matches(regex) #","categories":[],"tags":[]},{"title":"","slug":"java学习笔记 对象","date":"2018-01-15T08:56:37.700Z","updated":"2018-01-17T01:32:52.000Z","comments":true,"path":"2018/01/15/java学习笔记 对象/","link":"","permalink":"https://yuanleiuestc.github.io/2018/01/15/java学习笔记 对象/","excerpt":"","text":"基本概念COllection 一种存放一组对象的方式。12345678910111213141516package com.yuan.holding;import java.util.ArrayList;import java.util.Collection;public class SimpleCollection &#123;public static void main(String args[])&#123; Collection&lt;Integer&gt; c= new ArrayList&lt;Integer&gt;(); for(int i=0;i&lt;10;i++)&#123; c.add(i); &#125; for(Integer i :c)&#123; System.out.println(i+&quot; &quot;); &#125;&#125;&#125; #添加一组元素：Arrays.aslist()Collections.addAll(); 容器的打印list : ArrayList LinkedListMAP:HashMap,TreeMap,LinkedHashMapSet: HashSet,TreeSet,LinkedHashSet LinkLinkedlist实现了队列和堆栈的接口。 #迭代器IteratorhasNext()检查序列中是否还有元素next() 获得序列的下一个元素ListIterator 可以双向异动。 set集合，HashMap(散列表),TreeMap(红黑树),LinkedHashMap保存不重复的元素。Set是接口 MapQUEUEiterable12345678910111213141516171819202122232425262728293031323334353637package com.yuan.holding;import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;import java.util.Iterator;class ReversibleArrayList&lt;T&gt; extends ArrayList&lt;T&gt;&#123; public ReversibleArrayList(Collection&lt;T&gt; c)&#123;super(c);&#125; public Iterable&lt;T&gt; reversed()&#123; return new Iterable&lt;T&gt;()&#123; public Iterator&lt;T&gt; iterator()&#123; return new Iterator&lt;T&gt;()&#123; int current = size()-1; public boolean hasNext()&#123;return current&gt;-1;&#125; public T next()&#123;return get(current--);&#125; public void remove()&#123; throw new UnsupportedOperationException(); &#125; &#125;; &#125; &#125;; &#125;&#125;public class AdapterMethodIdiom &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stubReversibleArrayList&lt;String&gt; ral = new ReversibleArrayList&lt;String&gt;(Arrays.asList((&quot;To be or not to be&quot;).split(&quot; &quot;)));for(String s: ral)&#123; System.out.print(s+&quot; &quot;);&#125;for(String s1 :ral.reversed())&#123; System.out.print(s1+&quot; &quot;);&#125;&#125; &#125;","categories":[],"tags":[]},{"title":"","slug":"面试题","date":"2018-01-11T09:37:03.040Z","updated":"2018-02-09T07:06:14.000Z","comments":true,"path":"2018/01/11/面试题/","link":"","permalink":"https://yuanleiuestc.github.io/2018/01/11/面试题/","excerpt":"","text":"36.Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)?java的堆是存放是对象。永生代，出生代和老年代。 37.串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？串行收集器在GC时会停止其他所有工作线程（stop-the-world），CPU利用率是最高的，所以适用于要求高吞吐量（throughput）的应用，但停顿时间（pause time）会比较长，所以对web应用来说就不适合，因为这意味着用户等待时间会加长。而并行收集器可以理解是多线程串行收集，在串行收集基础上采用多线程方式进行GC，很好的弥补了串行收集的不足，可以大幅缩短停顿时间（如下图表示的停顿时长高度，并发比并行要短），因此对于空间不大的区域（如young generation），采用并行收集器停顿时间很短，回收效率高，适合高频率执行。 38在Java中，对象什么时候可以被垃圾回收？不存在对当前对象的引用时会出现垃圾回收 正在开始时候：1.内存满的时候2空闲的时候，java虚拟机决定。。39.JVM的永久代中会发生垃圾回收么？垃圾回收不会发生在永久代，如果永久代满了或超出了临界值，会触发jvm的完全垃圾回收 40.Java中的两种异常类型是什么？他们有什么区别？java的异常分类Error和Execption,异常又分为运行时异常和检测异常。41.Java中Exception和Error有什么区别？Exception和Error都是Throwable的子类。Exception用于用户程序可以捕获的异常情况。Error定义了不期望被用户程序捕获的异常。 42.throw和throws有什么区别？1.所在位置不同：throw语句用在方法体内，表示抛出异常，由方法体内的语句处理。throws语句用在方法声明后面，表示再抛出异常，由该方法的调用者来处理。2.动作不同throws主要是声明这个方法会抛出这种类型的异常，使它的调用者知道要捕获这个异常。throw是具体向外抛异常的动作，所以它是抛出一个异常实例。 throws说明你有那个可能，倾向。throw的话，那就是你把那个倾向变成真实的了。 同时：1、throws出现在方法函数头；而throw出现在函数体。2、throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常。3、两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。 43.异常处理完成后，Exception对象会发生什么变化？ Exception对象会在下一次垃圾回收过程中被回收掉。 44.finally代码块和finalize()方法有什么区别？ 无论是否抛出异常，finally代码块都会执行，它主要是用来释放应用占用的资源。finalize()方法是Object类的一个protected方法，它是在对象被垃圾回收之前由Java虚拟机来调用的。 45.什么是Applet？ Java应用小程序，可以直接嵌入到网页中，并能够产生特殊的效果，applet经编译后会产生.class文件，把.class文件嵌入到html页面中，用户在链接网页时，applet便会伴随网页一起下载到用户计算机运行。applet主要用来创建动态交互的web应用程序。 46.什么是JDBC？12345678910JDBC（Java DataBase Connectivity）,是一套面向对象的应用程序接口（API），制定了统一的访问各类关系数据库的标准接口，为各个数据库厂商提供了标准的实现。通过JDBC技术，开发人员可以用纯Java语言和标准的SQL语句编写完整的数据库应用程序，并且真正地实现了软件的跨平台性。通常情况下使用JDBC完成以下操作：1.同数据库建立连接；2.向数据库发送SQL语句；3.处理从数据库返回的结果；JDBC具有下列优点：1.JDBC与ODBC(Open Database Connectivity，即开放数据库互连）十分相似，便于软件开发人员理解；2.JDBC使软件开发人员从复杂的驱动程序编写工作中解脱出来，可以完全专注于业务逻辑开发；3.JDBC支持多种关系型数据库，大大增加了软件的可移植性；4.JDBC API是面向对象的，软件开发人员可以将常用的方法进行二次封装，从而提高代码的重用性； 47.Class.forName()方法有什么作用？1以通过这个来动态加载类。反射。 48.PreparedStatement比Statement有什么优势？ PreparedStatements是预编译的，PreparedStatements实例包涵已编译的sql语句，所以其执行呢速度要快于statement对象。 PreparedStatements作为statement的子类，继承了statement的所有方法，三种方法，excute,excuteQuery和excuteUpdate已被更改以使之不再需要参数。 PreparedStatements的代码可读性，可维护性强于statement. 极大的提高了安全性 49.什么时候使用CallableStatement？用来准备CallableStatement的方法是什么？ CallableStatement用来执行存储过程，存储过程是数据库存储和提供的，存储过程可以接受输入参数，也可以有返回结果。50.数据库连接池是什么意思？ 像打开关闭数据库连接这种和数据库的交互可能是很费时的，尤其是当客户端数量增加的时候，会消耗大量的资源，成本是非常高的。可以在应用服务器启动的时候建立很多个数据库连接并维护在一个池中。连接请求由池中的连接提供。在连接使用完毕以后，把连接归还到池中，以用于满足将来更多的请求。51.解释下Serialization和Deserialization。 Java提供了一种叫做对象序列化的机制，他把对象表示成一连串的字节，里面包含了对象的数据，对象的类型信息，对象内部的数据的类型信息等等。因此，序列化可以看成是为了把对象存储在磁盘上或者是从磁盘上读出来并重建对象而把对象扁平化的一种方式。反序列化是把对象从扁平状态转化成活动对象的相反的步骤。 52.什么是Servlet？servlet是基于java语言的web服务器端编程技术，是sun提供的一种实现动态网页的解决方案。servlet是运行在servlet容器中的java类，它能处理客户端的http请求并产生http响应 53.说一下Servlet的体系结构。http://blog.csdn.net/robinjwong/article/details/17700011 54.解释下Servlet的生命周期。 123456Servlet程序是由WEB服务器调用，web服务器收到客户端的Servlet访问请求后：①Web服务器首先检查是否已经装载并创建了该Servlet的实例对象。如果是，则直接执行第④步，否则，执行第②步。 ②装载并创建该Servlet的一个实例对象。 ③调用Servlet实例对象的init()方法。 ④创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。 ⑤WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。 55.doGet()方法和doPost()方法有什么区别？12doGet：GET方法会把名值对追加在请求的URL后面。因为URL对字符数目有限制，进而限制了用在客户端请求的参数值的数目。并且请求中的参数值是可见的，因此，敏感信息不能用这种方式传递。速度快，适合查询，安全性低doPOST：POST方法通过把请求参数值放在请求体中来克服GET方法的限制，因此，可以发送的参数的数目是没有限制的。最后，通过POST请求传递的敏感信息对外部客户端是不可见的。安全性高。 56.什么是cookie？session和cookie有什么区别？ cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户的状态，就使用response向客户端浏览器颁发一个cookie。客户端浏览器会把cookie保存起来。当浏览器再次请求该网站时，浏览器就会把请求地址和cookie一同给服务器。服务器检查该cookie，从而判断用户的状态。服务器还可以根据需要修改cookie的内容。 session是另一种记录客户状态的机制。不同的是cookie保存在客户端浏览器中，而session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。客户端浏览器再次访问时只需要从该session中查找该客户的状态就可以了。 如果说cookie机制是通过检查客户身上的“通信证”，那么session机制就是通过检查服务器上的“客户明细表”来确认客户身份。 57 浏览器和Servlet通信使用的是什么协议？浏览器和Servlet通信使用的是HTTP协议。 58什么是URL编码和URL解码？ URL编码是负责把URL里面的空格和其他的特殊字符替换成对应的十六进制表示，反之就是解码。 59.JSP有什么优点？JSP页面是被动态编译成Servlet的，因此，开发者可以很容易的更新展现代码。JSP页面可以被预编译。JSP页面可以很容易的和静态模板结合，包括：HTML或者XML，也可以很容易的和产生动态内容的代码结合起来。开发者可以提供让页面设计者以类XML格式来访问的自定义的JSP标签库。开发者可以在组件层做逻辑上的改变，而不需要编辑单独使用了应用层逻辑的页面。 60.隐含对象是什么意思？有哪些隐含对象？ JSP隐含对象是页面中的一些Java对象，JSP容器让这些Java对象可以为开发者所使用。开发者不用明确的声明就可以直接使用他们。JSP隐含对象也叫做预定义变量。下面列出了JSP页面中的隐含对象：applicationpagerequestresponsesessionexceptionoutconfigpageContext","categories":[],"tags":[]},{"title":"内部类.md","slug":"内部类-md","date":"2018-01-10T10:52:42.000Z","updated":"2018-01-11T09:36:42.000Z","comments":true,"path":"2018/01/10/内部类-md/","link":"","permalink":"https://yuanleiuestc.github.io/2018/01/10/内部类-md/","excerpt":"","text":"#内部类将一个类定义在另一个类的中。 10.3 使用.this和.new.this 使内部类生成外部类的引用。.new 去创建一个内部类的对象。 10.5在方法和作用域里的内部类目的：1.实现某个类型的接口，可以创建并返回对其的引用。2.解决一个复杂问题，想创建一个类来辅助你解决问题。在方法体类使用：1234567891011121314151617181920212223package com.yuan.innerclasses;public class Parcel5 &#123;public Destination destination(String s)&#123; class PDsestination implements Destination&#123; //内部类 private String label; private PDsestination (String whereTo)&#123; label= whereTo; &#125; @Override public String readLabel() &#123; // TODO Auto-generated method stub return label; &#125; &#125; return new PDsestination(s);&#125;public static void main(String args[])&#123; Parcel5 p = new Parcel5(); Destination d = p.destination(&quot;Tasmania&quot;);&#125;&#125; 在作用域内嵌入：12345678910111213141516171819202122232425package com.yuan.innerclasses;public class Parcel6 &#123;private void internalTracking(boolean b)&#123; if(b)&#123; class TrackSlip&#123; private String id; TrackSlip(String s)&#123; id=s; &#125; String getSlip()&#123; return id; &#125; &#125; TrackSlip ts = new TrackSlip(&quot;slip&quot;); String s = ts.getSlip();&#125; &#125;public void track()&#123; internalTracking(true);&#125;public static void main(String args[])&#123; Parcel6 p = new Parcel6(); p.track();&#125;&#125; 10.6匿名内部类123456789101112131415161718192021222324package com.yuan.innerclasses;public class Parcel10 &#123; public Destination destination(final String dest,final float price)&#123;//必须是final，才能被内部类使用。 return new Destination()&#123; private int cost; &#123; cost = Math.round(price); if(cost&gt;100) System.out.println(&quot;Over budget&quot;); &#125; private String label; public String readLabel() &#123; // TODO Auto-generated method stub return label; &#125; &#125;; &#125; public static void main(String args[])&#123; Parcel10 p = new Parcel10(); Destination d = p.destination(&quot;Tasmania&quot;,121.2f); &#125;&#125;` 工厂模式1234567891011121314151617181920212223242526272829303132333435363738394041package com.yuan.innerclasses;interface Game&#123;void play();&#125;interface GameService &#123;Game getGame();&#125;class Check implements Game&#123; private Check()&#123;&#125;; public void play()&#123; System.out.println(&quot;PlayCheck&quot;); &#125; static GameService gs = new GameService()&#123; public Game getGame()&#123; return new Check(); &#125;&#125;;&#125; class Chess implements Game&#123; private Chess()&#123;&#125;; public void play()&#123; System.out.println(&quot;PlayChess&quot;); &#125;static GameService gs = new GameService()&#123; public Game getGame()&#123; return new Chess(); &#125;&#125;; &#125;public class Games &#123; static void PalyGame(GameService g)&#123; Game s= g.getGame(); s.play(); &#125;public static void main(String args[])&#123; PalyGame(Chess.gs); PalyGame(Check.gs); &#125;&#125; 10.7嵌套类如果不需要内部类对象和外部类对象之间有联系，那么可以将内部类声明为static.特点： 创建嵌入类的对象，并不需要其外部类的对象 不能从嵌入类的对象访问非静态的外部类对象。 接口内部类为什么需要内部类：可以实现多重继承。 内部类的继承1234567891011package com.yuan.innerclasses;class WithInner&#123; class Inner&#123;&#125;&#125;public class InheritInner extends WithInner.Inner&#123; InheritInner(WithInner i)&#123; i.super(); &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"java学习笔记 接口","date":"2018-01-09T07:42:59.020Z","updated":"2018-01-11T01:32:20.000Z","comments":true,"path":"2018/01/09/java学习笔记 接口/","link":"","permalink":"https://yuanleiuestc.github.io/2018/01/09/java学习笔记 接口/","excerpt":"","text":"接口9.1 抽象类抽象方法包含抽象类方法的类叫抽象类。当继承一个抽象类的时候时候，必须实现所有的抽象方法。 9.2 接口· 更进一步的抽象，没有提供任何具体的实现。 使用关键字interface 类实现接口采用关键字implements 接口中的方法都被定义成public,如果没有声明，他们自动也是public12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.yuan.interfaces.music;import com.yuan.interfaces.music.Note;interface Instrument&#123; int Vlaue = 5 ;//static&amp;final void play(Note e); void adjust();&#125;class Wind implements Instrument&#123; @Override public void play(Note e) &#123; // TODO Auto-generated method stub System.out.println(this + &quot;.play()&quot;+e); &#125; public String toString()&#123;return &quot;Wind&quot;;&#125; @Override public void adjust() &#123; // TODO Auto-generated method stub System.out.println(this + &quot;.adjust()&quot;); &#125; &#125;class Percussion implements Instrument&#123; @Override public void play(Note e) &#123; // TODO Auto-generated method stub System.out.println(this + &quot;.play()&quot;+e); &#125; public String toString()&#123;return &quot;Percussion&quot;;&#125; @Override public void adjust() &#123; // TODO Auto-generated method stub System.out.println(this + &quot;.adjust()&quot;); &#125; &#125;class Stringed implements Instrument&#123; @Override public void play(Note e) &#123; // TODO Auto-generated method stub System.out.println(this + &quot;.play()&quot;+e); &#125; public String toString()&#123;return &quot;Stringed&quot;;&#125; @Override public void adjust() &#123; // TODO Auto-generated method stub System.out.println(this + &quot;.adjust()&quot;); &#125; &#125;class Brass extends Wind&#123; public String toString()&#123;return &quot;Brass&quot;;&#125; &#125;class WoodWind extends Wind&#123; @Override public String toString()&#123;return &quot;WoodWind&quot;;&#125; &#125;public class Music &#123; static void tunc(Instrument i)&#123; i.play(Note.B_FLAY); &#125; static void tuncAll(Instrument[] e)&#123; for(Instrument i:e) tunc(i); &#125; public static void main(String args[])&#123; Instrument[] i =&#123; new Wind(), new Percussion(), new Stringed(), new Brass(), new WoodWind() &#125;; tuncAll(i); &#125;&#125; 9.3 完全解耦 策略模式：创建一个能够根据传递的参数对象不同而具有不同的行为的方法。 #9.4 JAVA 中的多重继承 java可以通过接口实现多重继承。 使用借口的核心原因：1.向上转型为多个基类型。2防止客户端程序员创建该类的对象、 9.5通过继承来扩展接口 extends 可以应用多个接口、","categories":[],"tags":[]},{"title":"访问权限控制","slug":"访问权限控制","date":"2018-01-08T04:25:45.000Z","updated":"2018-01-08T04:36:12.000Z","comments":true,"path":"2018/01/08/访问权限控制/","link":"","permalink":"https://yuanleiuestc.github.io/2018/01/08/访问权限控制/","excerpt":"","text":"Java有四种访问权限， 其中三种有访问权限修饰符，分别为private，public和protected，还有一种不带任何修饰符。 private: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。 default：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访问。 protect: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。 public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包（package）访问。 public protect default private 不同包非子类 √ 不同包的子类 √ √ 同一个包 √ √ √ 同一个类 √ √ √ √","categories":[],"tags":[]},{"title":"Oracle表空间","slug":"Oracle表空间","date":"2017-11-28T15:07:57.000Z","updated":"2017-12-28T15:20:06.000Z","comments":true,"path":"2017/11/28/Oracle表空间/","link":"","permalink":"https://yuanleiuestc.github.io/2017/11/28/Oracle表空间/","excerpt":"","text":"1.查看表空间 SELECT t.tablespace_name, round(SUM(bytes / (1024 * 1024)), 0) ts_size FROM dba_tablespaces t, dba_data_files d WHERE t.tablespace_name = d.tablespace_name GROUP BY t.tablespace_name; select b.file_id 文件ID号, b.tablespace_name 表空间名, b.bytes/1024/1024||'M'字节数, (b.bytes-sum(nvl(a.bytes,0)))/1024/1024||'M' 已使用, sum(nvl(a.bytes,0))/1024/1024||'M' 剩余空间, 100 - sum(nvl(a.bytes,0))/(b.bytes)*100 占用百分比 from dba_free_space a,dba_data_files b where a.file_id=b.file_id group by b.tablespace_name,b.file_id,b.bytes order by b.file_id; --查看表空间大小 # 2 创建用户表空间 CREATE TABLESPACE test //创建表空间test LOGGING DATAFILE 'D:\\ORACLE\\PRODUCT\\10.2.0\\ORADATA\\ORCL\\TEST01.DBF' //创建的数据文件 SIZE 32M //初始大小 AUTOEXTEND ON //数据文件自动扩容 NEXT 32M MAXSIZE 2048M //最大值 EXTENT MANAGEMENT LOCAL; # 3 删除表空间，同时删除数据文件 drop tablespace test including contents and datafiles; # 4 创建用户临时表空间 CREATE TEMPORARY TABLESPACE test_temp TEMPFILE 'D:\\oracle\\product\\10.2.0\\oradata\\orcl\\test_temp01.dbf' SIZE 32M AUTOEXTEND ON NEXT 32M MAXSIZE 2048M --最大值 EXTENT MANAGEMENT LOCAL; # 5 创建用户并指定表空间： CREATE USER xiaoming IDENTIFIED BY xm123 //创建用户xiaoming，设置密码为xm123 DEFAULT TABLESPACE TEST //指定默认表空间为test TEMPORARY TABLESPACE TEST_TEMP; //指定临时表空间为test_temp","categories":[],"tags":[]},{"title":"python学习笔记3","slug":"python学习笔记3","date":"2017-08-18T00:57:10.000Z","updated":"2017-08-18T01:03:44.000Z","comments":true,"path":"2017/08/18/python学习笔记3/","link":"","permalink":"https://yuanleiuestc.github.io/2017/08/18/python学习笔记3/","excerpt":"#字典 映射：通过名字来引用值的数据结构。 python唯一内建的映射结构是字典，字典中的值没有特殊的顺序，但是都存储在特定的一个键（key）下，键可以是数字，字符串和元组。 字典的创建和使用创建字典","text":"#字典 映射：通过名字来引用值的数据结构。 python唯一内建的映射结构是字典，字典中的值没有特殊的顺序，但是都存储在特定的一个键（key）下，键可以是数字，字符串和元组。 字典的创建和使用创建字典 字典中的键是唯一的，而值并不唯一，通过键来找到对应的值。 字典的创建是由多个键和对应的值构成的键-值对组成，其中每个键和值之间用冒号（：）隔开，项之间用逗号隔开。12phonebook=&#123;&apos;petty&apos;:&apos;1234&apos;,&apos;Beth&apos;:&apos;1209&apos;,&apos;Cei&apos;:&apos;0123&apos;&#125;phone =&#123;&#125; #空字典 dict 函数通过其它映射（比如其它字典）或者（键，值）对的序列来创建字典也可以通过关键字创建字典12345&gt;&gt;&gt;item = [(&apos;petty&apos;,&apos;Beth&apos;),(&apos;1234&apos;,&apos;1209&apos;)]&gt;&gt;&gt;d = dict(item) #dict不是真正的函数，有点类似与list,tuple ,str&#123;&apos;petty&apos;:&apos;Beth&apos;,&apos;1234&apos;:&apos;1209&apos;&#125;&gt;&gt;&gt;d=dict(name=&apos;petty&apos;,age=12)&#123;&apos;name&apos;：&apos;petty&apos;,&apos;age&apos;=12&#125; 基本字典操作12345len(d) 返回d中项的数目 d[k] 返回健值为k的值d[k] =v 将值v关联到键值k上del d[k] 删除键值为k的项k in d 检验d字典中是否包含键值为k的项 字典和和列表的区别 键的类型，字典的键不一定为整数模型，键的值可以是任意类型，比如:浮点型，字符串或者元组 自动添加，即使键起初在字典中不存在，也可以直接进行赋值，而列表必须使用append函数，并且还必须在列表的范围之内 成员资格 ，字典是查找的是键，而不是值。 在字典中检查键的成员资格比在列表中检验值的成员资格更加的高效。 字典的格式化字符串在% 后面加上键（用括号括起来）123&gt;&gt;&gt;d=dict(name=&apos;petty&apos;,age=12)&gt;&gt;&gt;print(&apos;my name is %(name)s.&apos; % d)my name is petty 字典的方法1 clear 清除字典中所有的项2 copy 返回一个具有相同键值的字典（浅复制）12345678&gt;&gt;&gt; x=&#123;&apos;username&apos;:&apos;admin&apos;,&apos;machine&apos;:[&apos;foo&apos;,&apos;bar&apos;,&apos;baz&apos;]&#125;&gt;&gt;&gt; y=x.copy() #浅复制&gt;&gt;&gt; y[&apos;username&apos;]=&apos;mlh&apos; #修改字典的某个值&gt;&gt;&gt; y[&apos;machine&apos;].remove(&apos;bar&apos;) #删除字典的某个值&gt;&gt;&gt; x&#123;&apos;username&apos;: &apos;admin&apos;, &apos;machine&apos;: [&apos;foo&apos;, &apos;baz&apos;]&#125; #修改的值对原字典没有影响，删除的值对原字典有影响&gt;&gt;&gt; y&#123;&apos;username&apos;: &apos;mlh&apos;, &apos;machine&apos;: [&apos;foo&apos;, &apos;baz&apos;]&#125; 浅复制当在副本中进行替换时候，原来的字典不受影响，但是，如果修改了某个值，原始的字典也会改变。 深复制用copy模块的deepcopy12345678910&gt;&gt;&gt; from copy import deepcopy #导入deepcopy函数&gt;&gt;&gt; d=&#123;&#125;&gt;&gt;&gt; d[&apos;names&apos;]=[&apos;Alfred&apos;,&apos;Bertrand&apos;]&gt;&gt;&gt; c=d.copy() #浅复制&gt;&gt;&gt; dc=deepcopy(d) #深复制&gt;&gt;&gt; d[&apos;names&apos;].append(&apos;Clice&apos;) #修改原字典的内容&gt;&gt;&gt; c&#123;&apos;names&apos;: [&apos;Alfred&apos;, &apos;Bertrand&apos;, &apos;Clice&apos;]&#125; #浅复制的新字典也随着修改了&gt;&gt;&gt; dc&#123;&apos;names&apos;: [&apos;Alfred&apos;, &apos;Bertrand&apos;]&#125; #深复制的新字典没有改变 3 formkeys 使用给点的键建立字典，每个键都对应一个默认的值None123456&gt;&gt;&gt; &#123;&#125;.fromkeys([&apos;name&apos;,&apos;age&apos;])&#123;&apos;age&apos;: None, &apos;name&apos;: None&#125;&gt;&gt;&gt; dict.fromkeys([&apos;name&apos;,&apos;age&apos;]) #也可以用dict函数&#123;&apos;age&apos;: None, &apos;name&apos;: None&#125;&gt;&gt;&gt; dict.fromkeys([&apos;name&apos;,&apos;age&apos;],&apos;(unknown)&apos;) #不用默认的None，自己通过默认值&#123;&apos;age&apos;: &apos;(unknown)&apos;, &apos;name&apos;: &apos;(unknown)&apos;&#125; 4 get 根据键值，返回valie的值，如果为空，则返回none12345678910111213&gt;&gt;&gt; d=&#123;&#125;&gt;&gt;&gt; print d[&apos;name&apos;] #打印字典里面没有的键会报错Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: &apos;name&apos;&gt;&gt;&gt; print (d.get(&apos;name&apos;)) #用get方法就不会，打印NoneNone&gt;&gt;&gt; d.get(&apos;name&apos;,&apos;N/A&apos;) #取代默认的None，用N/A来替代&apos;N/A&apos;``` ### 5 setdefault 当键值不存在时候，返回默认值，并跟新字典，如果存在，则返回与其对应的值 d={}d.setdefault(‘name’,’N/A’) #如果不设定值，默认是None‘N/A’d{‘name’: ‘N/A’}d[‘name’]=’Gumby’d.setdefault(‘name’,’N/A’) #当键为’name’的值不会空时，就不能设置了，返回对应的值‘Gumby’d{‘name’: ‘Gumby’}1234### 6 update 利用一个字典更新领一个字典提供的新的字典的项会被加入到旧的字典中，重复的键会被覆盖。 phonebook={‘Alice’:’2341’,’Beth’:’9102’,’Cecil’:’3258’}x={‘Alice’:’changed’}phonebook.update(x) #更新键’Alice’对应的值phonebook{‘Beth’: ‘9102’, ‘Alice’: ‘changed’, ‘Cecil’: ‘3258’}x={‘Alicex’:’changed’} #没有相同的键，直接添加到旧的字典里面phonebook.update(x)phonebook{‘Beth’: ‘9102’, ‘Alice’: ‘changed’, ‘Alicex’: ‘changed’, ‘Cecil’: ‘3258’}123456### 7 items 字典中所有的项以~~列表~~方式返回,以views的形式返回,返回的内容用for循环遍历### 8 values 字典中的值以~~列表~~的方式返回,以views的形式返回,返回的内容用for循环遍历### 9 keys 字典中的键以~~列表~~的方式返回,以views的形式返回,返回的内容用for循环遍历dict methods dict.keys(), dict.items() and dict.values() return “views” instead of lists. a={‘name’:’yuan’,’age’:’26’}b=a.items()for k, v in b: print(k,v) 1234### 10 pop 用来获取指定键的值，并将这个键-值项从字典中移除 phonebook={‘Alice’:’2341’,’Beth’:’9102’,’Cecil’:’3258’}phonebook.pop(‘Alice’) #移除键’Alice’以及对应的值‘2341’phonebook{‘Beth’: ‘9102’, ‘Cecil’: ‘3258’}``` 11 popitem 弹出随机项","categories":[],"tags":[]},{"title":"python学习笔记2","slug":"python学习笔记2","date":"2017-08-17T00:42:41.000Z","updated":"2017-08-17T00:46:50.000Z","comments":true,"path":"2017/08/17/python学习笔记2/","link":"","permalink":"https://yuanleiuestc.github.io/2017/08/17/python学习笔记2/","excerpt":"字符串字符串的基本操作字符串：字符串可以使用所有通用的序列操作（索引，分片，判断成员资格，乘法，求长度，最大值，最小值（unicode码）），字符串与元组一样，同样是不可变的序列。 字符串的格式化使用字符串格式化操作符(%)来实现，如果格式化字符串里面有%，必须使用%%，这样Python就不会把%当成格式化操作符 1234&gt;&gt;&gt; format=&quot;Hello, %s. %s is a good day!&quot; #指定后面格式化为字符串&gt;&gt;&gt; values=(&apos;Clef&apos;,&apos;It&apos;)&gt;&gt;&gt; print （format % values）Hello, Clef. It is a good day!","text":"字符串字符串的基本操作字符串：字符串可以使用所有通用的序列操作（索引，分片，判断成员资格，乘法，求长度，最大值，最小值（unicode码）），字符串与元组一样，同样是不可变的序列。 字符串的格式化使用字符串格式化操作符(%)来实现，如果格式化字符串里面有%，必须使用%%，这样Python就不会把%当成格式化操作符 1234&gt;&gt;&gt; format=&quot;Hello, %s. %s is a good day!&quot; #指定后面格式化为字符串&gt;&gt;&gt; values=(&apos;Clef&apos;,&apos;It&apos;)&gt;&gt;&gt; print （format % values）Hello, Clef. It is a good day! 格式化操作符的右操作数可以是任何东西，如果是元组或者映射类型，那么字符串格式化将会有所不同。如果有操作数是元组的话，则其中的每一个元素都会被单独格式化，每个值都需要一个对应的转换说明符12&gt;&gt;&gt; &apos;%s plus %s equals %s&apos; % (1,2,3)&apos;1 plus 2 equals 3&apos; 模版字符串String某块提供一种模版字符串的方法。 string.Template()内添加替换的字符, 使用”$”符号, 或 在字符串内, 使用”${}”; 调用时使用string.substitute(dict)函数. 12345from string import Templates=Template(&quot;my name is $x&quot;)s.substitute(x=&apos;pettr&apos;)print(s.substitute(x=&apos;pettr&apos;)) 1%字符：标记转换说明符的开始2转换标志(可选)：- 表示左对齐；+ 表示在转换值之前要加上正负号；” “(空白字符)表示正数之前保留的空格；0表示转换值若位数不够则用0填充3最小字符宽度(可选)：转换后的字符串至少应该具有该值指定的宽度。如果是，4点(.)后跟精度值(可选)：如果转换的是实数，精度值就表示出现在小数点后的位数。如果转换的是字符串，那么该数字就表示最大字段宽度。如果是，那么精度将会从元组中读出12345678&gt;&gt;&gt; &apos;%.5s&apos; % &apos;Guido van Rossum&apos; #&apos;5&apos;表示最大字段宽度&apos;Guido&apos;&gt;&gt;&gt; from math import pi&gt;&gt;&gt; &apos;%10.2f&apos; % pi #字段宽度为10，精度为2&apos; \\3.14&apos;&gt;&gt;&gt; &apos;%.*s&apos; % (5, &apos;Guido van Rossum&apos;) #使用*，表示从元组参数中读取字符宽度或者精度，这里为字符宽度为5&apos;Guido&apos; 字符串方法string 模块中’集成’了很多了方法。有用的字符串常量string.digits：包含数字0~9的字符串string.letters：包含所有字母(大写或小写)的字符串string.lowercase：包含所有小写字母的字符串string.printable：包含所用可打印字符的字符串string.punctuation：包含所有标点的字符串string.uppercase：包含所有大写字母的字符串123&gt;&gt;&gt; import string&gt;&gt;&gt; string.letters #这里使用的是2.6.6版本的Python&apos;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&apos; 字符串方法： find 可以在一个较长的字符串中查找子字符串，它返回子串所在位置的最左端索引，如果没有找到则返回-112345&gt;&gt;&gt; my_strings=&quot;This is testing&quot;&gt;&gt;&gt; my_strings.find(&apos;is&apos;)2&gt;&gt;&gt; my_strings.find(&apos;clef&apos;)-1 in操作符只能查找字符串中的单个字符。 join 是split的逆方法，被连接的序列元素必须是字符串123456789101112&gt;&gt;&gt; my_list=[1,2,3,4,5]&gt;&gt;&gt; my_string=&apos;+&apos;&gt;&gt;&gt; my_string.join(my_list) #需要添加的队列元素必须是字符串Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: sequence item 0: expected string, int found&gt;&gt;&gt; my_list=[&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;]&gt;&gt;&gt; my_string.join(my_list)&apos;1+2+3+4+5&apos;&gt;&gt;&gt; dirs=&apos;&apos;,&apos;usr&apos;,&apos;bin&apos;,&apos;env&apos; #这里为元组还是可以进行添加&gt;&gt;&gt; &apos;/&apos;.join(dirs)&apos;/usr/bin/env&apos; lower 返回字符串的小写12345&gt;&gt;&gt; my_strings=&quot;This&quot;&gt;&gt;&gt; my_strings.lower()&apos;this&apos;&gt;&gt;&gt; my_strings #原字符串并没有改变&apos;This&apos; replace字符串中所有匹配项均被替换之后得到的字符串12&gt;&gt;&gt; &quot;It is a testing&quot;.replace(&apos;is&apos;,&apos;replaced&apos;) #用&apos;replaced&apos;替换&apos;is&apos;&apos;It replaced a testing&apos; split将字符串分割成序列 12&apos;1+2+3+4&apos;.split(&apos;+&apos;)[&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;] Strip返回去除字符串2侧（不包括中间）的空格，也可以指定需要去除的字符。 1234&gt;&gt;&gt; &apos; this is testing &apos;.strip() #去除了两侧的空格，并且保留了字符串内部的空格&apos;this is testing&apos;&gt;&gt;&gt; &apos;xxxthis is testing!!!xxx&apos;.strip(&apos;x!&apos;) #也可以用其他字符来代替默认的空格，这里用&apos;x&apos;或&apos;!&apos;来代替了默认的空格&apos;this is testing&apos; translate+maketrans方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。12345678910intab = &quot;aeiou&quot;outtab = &quot;12345&quot;trantab = str.maketrans(intab, outtab)str = &quot;this is string example....wow!!!&quot;print (str.translate(trantab))#输出th3s 3s str3ng 2x1mpl2....w4w!!!","categories":[],"tags":[]},{"title":"python 学习笔记1","slug":"python-学习笔记1","date":"2017-08-16T08:37:24.000Z","updated":"2017-08-16T09:03:56.000Z","comments":true,"path":"2017/08/16/python-学习笔记1/","link":"","permalink":"https://yuanleiuestc.github.io/2017/08/16/python-学习笔记1/","excerpt":"Python一种解释型的，面向对象的，带有动态语义的高级程序设计语言 第一章 基础知识1.1 基本运算符12+，-，*，/，%，//( 取整)，**（幂运算） 八进制 0o十六进制 0x长字符串用3个引号代替转义字符\\变量，语句，函数，模块等概念 2 列表和元组2.1 序列概述pythomn 最基本数据结构是序列，序列中的每个元素被分配一个序列——即元素的位置，也称为索引。第一个索引序号为0 Python中六种内建的序列 ： 列表，元祖，字符串，Unicode字符串，buffer对象.xrange对象 列表和元组的区别：列表是可以修改的，元组是不能的","text":"Python一种解释型的，面向对象的，带有动态语义的高级程序设计语言 第一章 基础知识1.1 基本运算符12+，-，*，/，%，//( 取整)，**（幂运算） 八进制 0o十六进制 0x长字符串用3个引号代替转义字符\\变量，语句，函数，模块等概念 2 列表和元组2.1 序列概述pythomn 最基本数据结构是序列，序列中的每个元素被分配一个序列——即元素的位置，也称为索引。第一个索引序号为0 Python中六种内建的序列 ： 列表，元祖，字符串，Unicode字符串，buffer对象.xrange对象 列表和元组的区别：列表是可以修改的，元组是不能的 2.2通用序列操作2.2.1索引序列中所有的元素都是有编号的–从0开始递增。可以通过编号分别对序列的元素进行访问。Python的序列也可以从右边开始索引，最右边的一个元素的索引为-1，想左开始递减。12345&gt;&gt;&gt;greeting =&apos;hello&apos;&gt;&gt;&gt;gteering[0]&apos;h&apos;&gt;&gt;&gt;gteering[-1]&apos;o&apos; 2.2.2 分片 使用分片可以访问一定范围内的元素,第一个索引的元素是包含在分片内的，第二个则不包含在分片内。1234567891011121314151617&gt;&gt;&gt; number=[1,2,3,4,5,6,7,8,9,10]&gt;&gt;&gt; number[2:4] #取索引为第二和第三的元素[3, 4]&gt;&gt;&gt; number[-4:-1] #负数表明是从右开始计数,不能到0[7, 8, 9]&gt;&gt;&gt; number[-4:] #把第二个索引置空，表明包括到序列结尾的元素[7, 8, 9, 10]&gt;&gt;&gt; number[:3] #同上，把第一个索引置空，表明包含序列开始的元素[1, 2, 3]&gt;&gt;&gt; number[0:10:1] #默认在分片的时候，步长为1,这样指定步长为1，和默认的效果一样[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&gt;&gt;&gt; number[0:10:2] #这里指定步长为2，这样就会跳过某些序列元素[1, 3, 5, 7, 9]&gt;&gt;&gt; number[10:0:-1] #步长也可以是负数，但是第一个索引一定要大于第二个索引[10, 9, 8, 7, 6, 5, 4, 3, 2]&gt;&gt;&gt; number[10:0:-2] [10, 8, 6, 4, 2] 2.2.3 序列相加使用加号运算符12345678&gt;&gt;&gt; [1,2,3]+[4,5,6][1, 2, 3, 4, 5, 6]&gt;&gt;&gt; &apos;Hello &apos;+&apos;World!&apos;&apos;Hello World!&apos;&gt;&gt;&gt; [1,2,3]+&apos;Hello&apos;Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: can only concatenate list (not &quot;str&quot;) to list 最后一个例子，试图列表和字符串进行相加，出错。两种相同类型的序列才能进行连接操作 2.2.4乘法用数字x剩以一个序列会生成新的序列，而在新的序列中，原来的序列将会被重复x次。1234&gt;&gt;&gt; &apos;python&apos;*4&apos;pythonpythonpythonpython&apos;&gt;&gt;&gt; [None]*4 #None为Python的内建值，这里创建长度为4的元素空间，但是什么元素也不包含[None, None, None, None] 2.2.5成员资格检测一个值是否存在序列当中 ，用IN运算符。 1234567891011&gt;&gt;&gt; permission=&apos;rw&apos;&gt;&gt;&gt; &apos;r&apos; in permissionTrue&gt;&gt;&gt; &apos;x&apos; in permissionFalse&gt;&gt;&gt;a =[1,2,3,4]&gt;&gt;&gt;1 in aTrue&gt;&gt;&gt; 5 in a False 2.2.6 长度，最小值，最大值len 长度max 最大值min 最小值123456789&gt;&gt;&gt; number=[2,3,4,5,6,7,8,9,10]&gt;&gt;&gt; len(number)9&gt;&gt;&gt; min(number)2&gt;&gt;&gt; max(number)10&gt;&gt;&gt; min(4,3,5) #函数的参数不用一定是序列，也可以是多个数字3 2.3 列表列表之间的元素用逗号隔开，可以存放不同的类型1a= [1,2,3,&apos;hello&apos;] 2.3.1 list函数1234&gt;&gt;&gt;list(&apos;hello&apos;)[&apos;h&apos;,&apos;e&apos;,&apos;l,&apos;l&apos;,&apos;o&apos;]&apos;&apos;.join(somelist) #将一个由字符组成的列表转换成字符串，如果既有字符也有数字会报错 2.3.2 基本的列表操作1 元素赋值123456&gt;&gt;&gt; x=[1,2,3]&gt;&gt;&gt; x[1, 2, 3]&gt;&gt;&gt; x[1]=4 #使用索引来标记某个特定位置，然后对位置明确的元素赋值&gt;&gt;&gt; x[1, 4, 3] 2 删除元素del1234&gt;&gt;&gt; name=[&apos;Clef&apos;,&apos;luo&apos;]&gt;&gt;&gt; del name[1] #直接删除列表的&apos;luo&apos;这个元素&gt;&gt;&gt; name[&apos;Clef&apos;] 3 分片赋值1234567891011121314151617181920212223242526&gt;&gt;&gt; name=list(&apos;Perl&apos;)&gt;&gt;&gt; name[&apos;P&apos;, &apos;e&apos;, &apos;r&apos;, &apos;l&apos;]&gt;&gt;&gt; name[2:]=list(&apos;ar&apos;) #对name指定序号为2和以后的进行赋值&gt;&gt;&gt; name[&apos;P&apos;, &apos;e&apos;, &apos;a&apos;, &apos;r&apos;]&gt;&gt;&gt; numbers=[1,5]&gt;&gt;&gt; numbers[1, 5]&gt;&gt;&gt; numbers[1:1]=[2,3,4] #直接插入新的列表元素&gt;&gt;&gt; numbers[1, 2, 3, 4, 5]&gt;&gt;&gt; numbers[1:4]=[] #指定删除相应的列表元素，和上面del语句效果一样的&gt;&gt;&gt; numbers[1, 5]&gt;&gt;&gt; name=list(&apos;Perl&apos;) #初始化列表name&gt;&gt;&gt; name1=name #直接赋值，表明name和name1同时引用一个列表&gt;&gt;&gt; name2=name[:] #把整个列表切片后再赋值，将会得到一个列表的副本，name2和name并不是指向同一个列表&gt;&gt;&gt; name[2]=&apos;x&apos;#修改列表name的值&gt;&gt;&gt; name[&apos;P&apos;, &apos;e&apos;, &apos;x&apos;, &apos;l&apos;]&gt;&gt;&gt; name1 #name1同时一起被修改了[&apos;P&apos;, &apos;e&apos;, &apos;x&apos;, &apos;l&apos;]&gt;&gt;&gt; name2 #但是name2并没有同时一起被修改[&apos;P&apos;, &apos;e&apos;, &apos;r&apos;, &apos;l&apos;] 2.3.2 列表的方法1.append用于在列表末尾追加新的对象1234&gt;&gt;&gt; numbers=[1,2,3]&gt;&gt;&gt; numbers.append(4) #直接追加新的列表元素&gt;&gt;&gt; numbers[1, 2, 3, 4] 2.count统计某个元素在列表中出现的次数123&gt;&gt;&gt; numbers=[1,2,1,2,3,4,2]&gt;&gt;&gt; numbers.count(2) #统计列表元素&apos;2&apos;出现的次数3 3.extend可以在列表的末尾一次性追加另一个序列中的多个值12345678&gt;&gt;&gt; a=[1,2,3]&gt;&gt;&gt; b=[4,5,6]&gt;&gt;&gt; a.extend(b)&gt;&gt;&gt; a[1, 2, 3, 4, 5, 6]也可以用分赋值实现a[len(a):]=b extend修改了原来表的结构，而直接用序列的相加则没有修改原来序列的值 4.index找出某个值第一个匹配项的索引位置1234&gt;&gt;&gt; numbers[1, 2, 1, 2, 3, 4, 2]&gt;&gt;&gt; numbers.index(2)1 5.insert将对象插入到列表当中12345&gt;&gt;&gt; numbers[1, 2, 1, 2, 3, 4, 2]&gt;&gt;&gt; numbers.insert(2,&apos;inserting&apos;) #指定序号为2的地方插入&apos;inserting&apos;&gt;&gt;&gt; numbers[1, 2, &apos;inserting&apos;, 1, 2, 3, 4, 2] 6.pop移除列表中的一个元素(默认是最后一个)，并且返回该元素的值，该方法是唯一一个既能修改列表又返回元素值(除None)的列表方法1234&gt;&gt;&gt; x=[1,2,3]&gt;&gt;&gt; x.pop()#移除最后一个元素&gt;&gt;&gt; x[1, 2] 可以和append搭配使用，实现栈的功能想实现堆的功能可以和insert搭配使用 7.remove移除列表中某个值的==第一个匹配项== 1234&gt;&gt;&gt; x=[1,2,3,2,4,5]&gt;&gt;&gt; x.remove(2) #只移除了列表中的第一个匹配到&apos;2&apos;的元素&gt;&gt;&gt; x[1, 3, 2, 4, 5] 8.reverse将列表中的元素反向存放1234&gt;&gt;&gt; x=[1,2,3,4,5]&gt;&gt;&gt; x.reverse()&gt;&gt;&gt; x[5, 4, 3, 2, 1] 该方法不返回值如果需要对有一个列表反向迭代，可以采用reversed函数123&gt;&gt;&gt;a=list(reversed(x))&gt;&gt;&gt;a[5, 4, 3, 2, 1] 9.sort对原列表进行排序，并返回空值,不返回值的方法123456&gt;&gt;&gt; x=[4,2,3,5,1]&gt;&gt;&gt; y=x.sort() #对列表x进行排序，并把返回值赋给y&gt;&gt;&gt; x #x列表已经排序[1, 2, 3, 4, 5]&gt;&gt;&gt; y #y为空，印证了上面说的，sort方法返回空值&gt;&gt;&gt; 可以将x先赋值给y1234567891011121314151617&gt;&gt;&gt; x=[4,2,3,5,1]&gt;&gt;&gt;y=x[:]&gt;&gt;&gt;y.sort()&gt;&gt;&gt;x[4,2,3,5,1]&gt;&gt;&gt;y[1, 2, 3, 4, 5]y=xy.sort&gt;&gt;&gt;x[1, 2, 3, 4, 5]&gt;&gt;&gt;y[1, 2, 3, 4, 5]#也可以直接使用sorted函数y= sorted(x) 10.高级排序key、reverse还是可以作为sort方法的参数12345678&gt;&gt;&gt; x=[&apos;abc&apos;,&apos;ab&apos;,&apos;abcd&apos;,&apos;a&apos;]&gt;&gt;&gt; x.sort(key=len) #根据元素的长度&gt;&gt;&gt; x[&apos;a&apos;, &apos;ab&apos;, &apos;abc&apos;, &apos;abcd&apos;]&gt;&gt;&gt; x=[5,2,9,7]&gt;&gt;&gt; x.sort(reverse=True) # True 方向排序&gt;&gt;&gt; x[9, 7, 5, 2] 2.4 元组 不可变序列元组：与列表一样，也是一种序列，唯一的不同就是元组不能修改。创建元组很简单，用逗号隔开一些值，就自动创建了元组，元组大部分的时候是通过圆括号括起来的。元组只有一个值的时候必须加逗号1234&gt;&gt;&gt; 3, #注意要加一个逗号，才能实现是元组(3,)&gt;&gt;&gt; () #空元组，不包含任何元素() tuple函数：功能与list函数基本上是一样的，以一个序列作为参数并把它转换为元组，如果参数是元组，那么就会原样返回该元组. 123456&gt;&gt;&gt; tuple([1,2,3]) #参数是列表，就转换为元组(1, 2, 3)&gt;&gt;&gt; tuple(&apos;abc&apos;) #与list函数用法一样(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)&gt;&gt;&gt; tuple((&apos;a&apos;,&apos;b&apos;,&apos;c&apos;)) #参数为元组，就返回原元组，字符要加引号(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;) 元组意义 元组在映射中当作键使用，而列表不行 元组作为很多内建函数和方法的返回值，也就是说必须对元组进行处理。","categories":[],"tags":[{"name":"study","slug":"study","permalink":"https://yuanleiuestc.github.io/tags/study/"}]},{"title":"Oracle学习","slug":"Oracle","date":"2017-07-28T01:13:01.000Z","updated":"2017-08-09T07:27:44.000Z","comments":true,"path":"2017/07/28/Oracle/","link":"","permalink":"https://yuanleiuestc.github.io/2017/07/28/Oracle/","excerpt":"","text":"Oracle 学习笔记11 oracle11g 概述1.1 oracle发展历史起源于1970年《大型共享数据库的关系模型》 目前已经到oracle12g ###1.2关系数据库基本理论数据库管理技术123graph LR; 人工管理--&gt;文件管理; 文件管理--&gt;数据库系统 数据模型123graph LR;层次模型 --&gt;网状模型;网状模型--&gt; 关系模型 1.2.1 ag","categories":[],"tags":[]},{"title":"Oracle学习","slug":"Oracle学习","date":"2017-07-28T01:13:01.000Z","updated":"2017-07-28T04:12:24.000Z","comments":true,"path":"2017/07/28/Oracle学习/","link":"","permalink":"https://yuanleiuestc.github.io/2017/07/28/Oracle学习/","excerpt":"","text":"#Oracle 学习笔记 ##1 oracle11g 概述 1.1 oracle发展历史起源于1970年《大型共享数据库的关系模型》目前已经到oracle12g ###1.2关系数据库基本理论数据库管理技术123graph LR; 人工管理--&gt;文件管理; 文件管理--&gt;数据库系统 数据模型层次模型 网状模型 关系模型 名称 属性 方法 测试 name test（） 测试 name test（） graph LR; A-->B; A-->C; B-->D; C-->D;{\"theme\":\"simple\",\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);","categories":[],"tags":[]},{"title":"java学习","slug":"java学习","date":"2017-07-22T02:02:59.000Z","updated":"2017-07-28T02:19:36.000Z","comments":true,"path":"2017/07/22/java学习/","link":"","permalink":"https://yuanleiuestc.github.io/2017/07/22/java学习/","excerpt":"","text":"#数组 ##一维数组数组：一组相同数据 数组类型[] 数组名数组类类型 数据名[] example int a = new int[]{1,2,3}int a = new int[3];a[0]=1;a[1]=2;a[2]=3;int[] a ={1,2,3};下表不能为负数，从o开始，最大下标为length-1;","categories":[],"tags":[]},{"title":"统计学","slug":"统计学","date":"2017-07-21T08:20:27.000Z","updated":"2017-07-31T09:19:10.000Z","comments":true,"path":"2017/07/21/统计学/","link":"","permalink":"https://yuanleiuestc.github.io/2017/07/21/统计学/","excerpt":"","text":"11章 总体和样本的估计 进行预测内容： 如何通过样本估计总体，如何通过总体了解样本 样本估计总体样本的均值被称为总体均值的点估计量 总体的均值可以用样本的均值进行评估。不能直接用样本的方差直接估计总体的方差。因为样本的方差会小于总体的离散程度。 样本的概率估计估计总体的概率总体的估计样本的概率 如果考虑同一个总体中所有大小为n的可能样本，然后用这些样本的均值形成分布我，则该分布为“均值的抽样分布”。 12章 置信区间的构建用样本来衡量总体，如果只是采用一个点，则可能有很大的误差，采用一个置信区间的更加的合理。求解置信区间的四步骤： 选择总体估计量 求出其抽样分布 决定置信水平 求出置信上下限 当样本数目比较大时，采用正态分布，当在用小样本估计总体方差时，T分布更加准确。 上2章介绍了两钟估计总体统计量的方法。 点估计量 使用总体统计量的置信区间 第13章 假设检验的应用假设检验的六个步骤 确定要进行检验的假设 选择检验统计量 确认用于做决策的拒绝域 求出检验统计量的P值 查看样本的结果是否位于拒绝域内 作出决策 第一类错误：原假设正确却拒绝原假设 ，即检验的显著水平第二类错误：原假设错误却接受原假设 第14章 卡方分布目的：检查实际结果与期望结果之间何时存在显著差别。 卡方统计量的用途： 检验拟合优度 检验2个变量的独立性。 卡方检验的六个步骤 确定要进行检验的假设以及备选假设 求出期望频数和自由度 确认用于做决策的拒绝域 计算检验统计量卡方 查看样本的结果是否位于拒绝域内 作出决策 第15章 相关和回归之前都是对单一的变量进行分析，现在对2个变量进行相关的分析。因变量和自变量","categories":[],"tags":[]},{"title":"时间序列预测 python实现","slug":"时间序列","date":"2017-07-08T14:00:30.000Z","updated":"2017-07-21T08:15:00.000Z","comments":true,"path":"2017/07/08/时间序列/","link":"","permalink":"https://yuanleiuestc.github.io/2017/07/08/时间序列/","excerpt":"","text":"#时间序列预测 python实现使用ARIMA实现。 ##理论知识ARIMA模型全称为自回归积分滑动平均模型(Autoregressive Integrated Moving Average Model,简记ARIMA)，ARIMA(p,d,q)称为差分自回归移动平均模型AR是”自回归”，p为自回归项数；MA为”滑动平均”，q为滑动平均项数，d为使之成为平稳序列所做的差分次数（阶数） 时间序列的假设：时间序列的行为不随时间改变。。数学知识不足，去学习相关的知识。 1.首先识别时间序列的稳定性，通过散点图，自相关函数，偏相关函数判断是否平稳2.如果不是平稳的，采用d阶查分，使得序列变得稳定。？？为什么算法要求文档呢AC自相关系数 ，PAC偏相关系数 3.根据所识别的特征建立相应的时间模型，自相关函数是拖尾的（？？）采用AR模型，偏相关拖尾的，采用 MA模型，自相关函数和偏相关函数都是拖尾的，则采用 ARMA模型","categories":[],"tags":[{"name":"学习，python","slug":"学习，python","permalink":"https://yuanleiuestc.github.io/tags/学习，python/"},{"name":"ARIMA","slug":"ARIMA","permalink":"https://yuanleiuestc.github.io/tags/ARIMA/"},{"name":"时间序列","slug":"时间序列","permalink":"https://yuanleiuestc.github.io/tags/时间序列/"}]},{"title":"hexo+github 博客搭建","slug":"hexo-github-博客搭建","date":"2017-07-07T14:01:30.000Z","updated":"2017-07-28T02:19:38.000Z","comments":true,"path":"2017/07/07/hexo-github-博客搭建/","link":"","permalink":"https://yuanleiuestc.github.io/2017/07/07/hexo-github-博客搭建/","excerpt":"Hexo+github博客搭建安装软件node.js , git 网上找资料下安装Hexo(本博客采用3.0版本) 打开Git Bash,执行下面命令 npm install -g hexo-cli 如果安装失败，采用淘宝的镜像","text":"Hexo+github博客搭建安装软件node.js , git 网上找资料下安装Hexo(本博客采用3.0版本) 打开Git Bash,执行下面命令 npm install -g hexo-cli 如果安装失败，采用淘宝的镜像 npm install -g cnpm --registry=https://registry.npm.taobao.org #本地建立文件夹E:\\hexo 进入目录，右键GitBash 执行 hexo init npm install hexo g hexo s 或者hexo s -g 之后输入http://localhost:4000/就能看到博客 ， 新的博客可以在E:\\hexo\\source\\_posts增加文件，md文件。 ##注册github 创建新的仓库，仓库名字必须是：username.github.io，其中username是你的用户名； ##配置SSHKey 主要是为了安全，直接提交代码需要github的代码，不是很安全，采用机密的方式更加安全。 ssh-keygen -t rsa -C \"邮件地址\" 密钥保存在C:\\Users\\yuan\\.ssh\\id_rsa.pub 密钥添加到github 入个人设置 -> SSH and GPG keys -> New SSH key 测试是否成功 ssh -T git@github.com 在设计 git config --global user.name \"yuanleiuestc\"// 你的github用户名，非昵称 git config --global user.email \"xxx@163.com\"// 填写你的github注册 ##配置_config.yml 3.0之前 deploy: type: git repository: http://github.com/huangjunhui/huangjunhui.github.io.git branch: master 3.0，目前我用的 url: https://yuanleiuestc.github.io #你的博客地址 deploy: type: git repository: git@github.com:yuanleiuestc/yuanleiuestc.github.io.git branch: maste 创建新博客 hexo new 'my-first-blog' editor.md编辑器 npm install hexo-deployer-git –save ##发布 hexo clean hexo generate hexo d 主题下载 git clone https://github.com/litten/hexo-theme-yilia.git","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"https://yuanleiuestc.github.io/tags/学习/"}]}]}