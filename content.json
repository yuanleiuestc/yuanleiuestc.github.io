{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"https://yuanleiuestc.github.io"},"pages":[],"posts":[{"title":"python学习笔记3","slug":"python学习笔记3","date":"2017-08-18T00:57:10.000Z","updated":"2017-08-18T01:03:44.000Z","comments":true,"path":"2017/08/18/python学习笔记3/","link":"","permalink":"https://yuanleiuestc.github.io/2017/08/18/python学习笔记3/","excerpt":"#字典 映射：通过名字来引用值的数据结构。 python唯一内建的映射结构是字典，字典中的值没有特殊的顺序，但是都存储在特定的一个键（key）下，键可以是数字，字符串和元组。 字典的创建和使用创建字典","text":"#字典 映射：通过名字来引用值的数据结构。 python唯一内建的映射结构是字典，字典中的值没有特殊的顺序，但是都存储在特定的一个键（key）下，键可以是数字，字符串和元组。 字典的创建和使用创建字典 字典中的键是唯一的，而值并不唯一，通过键来找到对应的值。 字典的创建是由多个键和对应的值构成的键-值对组成，其中每个键和值之间用冒号（：）隔开，项之间用逗号隔开。12phonebook=&#123;&apos;petty&apos;:&apos;1234&apos;,&apos;Beth&apos;:&apos;1209&apos;,&apos;Cei&apos;:&apos;0123&apos;&#125;phone =&#123;&#125; #空字典 dict 函数通过其它映射（比如其它字典）或者（键，值）对的序列来创建字典也可以通过关键字创建字典12345&gt;&gt;&gt;item = [(&apos;petty&apos;,&apos;Beth&apos;),(&apos;1234&apos;,&apos;1209&apos;)]&gt;&gt;&gt;d = dict(item) #dict不是真正的函数，有点类似与list,tuple ,str&#123;&apos;petty&apos;:&apos;Beth&apos;,&apos;1234&apos;:&apos;1209&apos;&#125;&gt;&gt;&gt;d=dict(name=&apos;petty&apos;,age=12)&#123;&apos;name&apos;：&apos;petty&apos;,&apos;age&apos;=12&#125; 基本字典操作12345len(d) 返回d中项的数目 d[k] 返回健值为k的值d[k] =v 将值v关联到键值k上del d[k] 删除键值为k的项k in d 检验d字典中是否包含键值为k的项 字典和和列表的区别 键的类型，字典的键不一定为整数模型，键的值可以是任意类型，比如:浮点型，字符串或者元组 自动添加，即使键起初在字典中不存在，也可以直接进行赋值，而列表必须使用append函数，并且还必须在列表的范围之内 成员资格 ，字典是查找的是键，而不是值。 在字典中检查键的成员资格比在列表中检验值的成员资格更加的高效。 字典的格式化字符串在% 后面加上键（用括号括起来）123&gt;&gt;&gt;d=dict(name=&apos;petty&apos;,age=12)&gt;&gt;&gt;print(&apos;my name is %(name)s.&apos; % d)my name is petty 字典的方法1 clear 清除字典中所有的项2 copy 返回一个具有相同键值的字典（浅复制）12345678&gt;&gt;&gt; x=&#123;&apos;username&apos;:&apos;admin&apos;,&apos;machine&apos;:[&apos;foo&apos;,&apos;bar&apos;,&apos;baz&apos;]&#125;&gt;&gt;&gt; y=x.copy() #浅复制&gt;&gt;&gt; y[&apos;username&apos;]=&apos;mlh&apos; #修改字典的某个值&gt;&gt;&gt; y[&apos;machine&apos;].remove(&apos;bar&apos;) #删除字典的某个值&gt;&gt;&gt; x&#123;&apos;username&apos;: &apos;admin&apos;, &apos;machine&apos;: [&apos;foo&apos;, &apos;baz&apos;]&#125; #修改的值对原字典没有影响，删除的值对原字典有影响&gt;&gt;&gt; y&#123;&apos;username&apos;: &apos;mlh&apos;, &apos;machine&apos;: [&apos;foo&apos;, &apos;baz&apos;]&#125; 浅复制当在副本中进行替换时候，原来的字典不受影响，但是，如果修改了某个值，原始的字典也会改变。 深复制用copy模块的deepcopy12345678910&gt;&gt;&gt; from copy import deepcopy #导入deepcopy函数&gt;&gt;&gt; d=&#123;&#125;&gt;&gt;&gt; d[&apos;names&apos;]=[&apos;Alfred&apos;,&apos;Bertrand&apos;]&gt;&gt;&gt; c=d.copy() #浅复制&gt;&gt;&gt; dc=deepcopy(d) #深复制&gt;&gt;&gt; d[&apos;names&apos;].append(&apos;Clice&apos;) #修改原字典的内容&gt;&gt;&gt; c&#123;&apos;names&apos;: [&apos;Alfred&apos;, &apos;Bertrand&apos;, &apos;Clice&apos;]&#125; #浅复制的新字典也随着修改了&gt;&gt;&gt; dc&#123;&apos;names&apos;: [&apos;Alfred&apos;, &apos;Bertrand&apos;]&#125; #深复制的新字典没有改变 3 formkeys 使用给点的键建立字典，每个键都对应一个默认的值None123456&gt;&gt;&gt; &#123;&#125;.fromkeys([&apos;name&apos;,&apos;age&apos;])&#123;&apos;age&apos;: None, &apos;name&apos;: None&#125;&gt;&gt;&gt; dict.fromkeys([&apos;name&apos;,&apos;age&apos;]) #也可以用dict函数&#123;&apos;age&apos;: None, &apos;name&apos;: None&#125;&gt;&gt;&gt; dict.fromkeys([&apos;name&apos;,&apos;age&apos;],&apos;(unknown)&apos;) #不用默认的None，自己通过默认值&#123;&apos;age&apos;: &apos;(unknown)&apos;, &apos;name&apos;: &apos;(unknown)&apos;&#125; 4 get 根据键值，返回valie的值，如果为空，则返回none12345678910111213&gt;&gt;&gt; d=&#123;&#125;&gt;&gt;&gt; print d[&apos;name&apos;] #打印字典里面没有的键会报错Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: &apos;name&apos;&gt;&gt;&gt; print (d.get(&apos;name&apos;)) #用get方法就不会，打印NoneNone&gt;&gt;&gt; d.get(&apos;name&apos;,&apos;N/A&apos;) #取代默认的None，用N/A来替代&apos;N/A&apos;``` ### 5 setdefault 当键值不存在时候，返回默认值，并跟新字典，如果存在，则返回与其对应的值 d={}d.setdefault(‘name’,’N/A’) #如果不设定值，默认是None‘N/A’d{‘name’: ‘N/A’}d[‘name’]=’Gumby’d.setdefault(‘name’,’N/A’) #当键为’name’的值不会空时，就不能设置了，返回对应的值‘Gumby’d{‘name’: ‘Gumby’}1234### 6 update 利用一个字典更新领一个字典提供的新的字典的项会被加入到旧的字典中，重复的键会被覆盖。 phonebook={‘Alice’:’2341’,’Beth’:’9102’,’Cecil’:’3258’}x={‘Alice’:’changed’}phonebook.update(x) #更新键’Alice’对应的值phonebook{‘Beth’: ‘9102’, ‘Alice’: ‘changed’, ‘Cecil’: ‘3258’}x={‘Alicex’:’changed’} #没有相同的键，直接添加到旧的字典里面phonebook.update(x)phonebook{‘Beth’: ‘9102’, ‘Alice’: ‘changed’, ‘Alicex’: ‘changed’, ‘Cecil’: ‘3258’}123456### 7 items 字典中所有的项以~~列表~~方式返回,以views的形式返回,返回的内容用for循环遍历### 8 values 字典中的值以~~列表~~的方式返回,以views的形式返回,返回的内容用for循环遍历### 9 keys 字典中的键以~~列表~~的方式返回,以views的形式返回,返回的内容用for循环遍历dict methods dict.keys(), dict.items() and dict.values() return “views” instead of lists. a={‘name’:’yuan’,’age’:’26’}b=a.items()for k, v in b: print(k,v) 1234### 10 pop 用来获取指定键的值，并将这个键-值项从字典中移除 phonebook={‘Alice’:’2341’,’Beth’:’9102’,’Cecil’:’3258’}phonebook.pop(‘Alice’) #移除键’Alice’以及对应的值‘2341’phonebook{‘Beth’: ‘9102’, ‘Cecil’: ‘3258’}``` 11 popitem 弹出随机项","categories":[],"tags":[]},{"title":"python学习笔记2","slug":"python学习笔记2","date":"2017-08-17T00:42:41.000Z","updated":"2017-08-17T00:46:50.000Z","comments":true,"path":"2017/08/17/python学习笔记2/","link":"","permalink":"https://yuanleiuestc.github.io/2017/08/17/python学习笔记2/","excerpt":"字符串字符串的基本操作字符串：字符串可以使用所有通用的序列操作（索引，分片，判断成员资格，乘法，求长度，最大值，最小值（unicode码）），字符串与元组一样，同样是不可变的序列。 字符串的格式化使用字符串格式化操作符(%)来实现，如果格式化字符串里面有%，必须使用%%，这样Python就不会把%当成格式化操作符 1234&gt;&gt;&gt; format=&quot;Hello, %s. %s is a good day!&quot; #指定后面格式化为字符串&gt;&gt;&gt; values=(&apos;Clef&apos;,&apos;It&apos;)&gt;&gt;&gt; print （format % values）Hello, Clef. It is a good day!","text":"字符串字符串的基本操作字符串：字符串可以使用所有通用的序列操作（索引，分片，判断成员资格，乘法，求长度，最大值，最小值（unicode码）），字符串与元组一样，同样是不可变的序列。 字符串的格式化使用字符串格式化操作符(%)来实现，如果格式化字符串里面有%，必须使用%%，这样Python就不会把%当成格式化操作符 1234&gt;&gt;&gt; format=&quot;Hello, %s. %s is a good day!&quot; #指定后面格式化为字符串&gt;&gt;&gt; values=(&apos;Clef&apos;,&apos;It&apos;)&gt;&gt;&gt; print （format % values）Hello, Clef. It is a good day! 格式化操作符的右操作数可以是任何东西，如果是元组或者映射类型，那么字符串格式化将会有所不同。如果有操作数是元组的话，则其中的每一个元素都会被单独格式化，每个值都需要一个对应的转换说明符12&gt;&gt;&gt; &apos;%s plus %s equals %s&apos; % (1,2,3)&apos;1 plus 2 equals 3&apos; 模版字符串String某块提供一种模版字符串的方法。 string.Template()内添加替换的字符, 使用”$”符号, 或 在字符串内, 使用”${}”; 调用时使用string.substitute(dict)函数. 12345from string import Templates=Template(&quot;my name is $x&quot;)s.substitute(x=&apos;pettr&apos;)print(s.substitute(x=&apos;pettr&apos;)) 1%字符：标记转换说明符的开始2转换标志(可选)：- 表示左对齐；+ 表示在转换值之前要加上正负号；” “(空白字符)表示正数之前保留的空格；0表示转换值若位数不够则用0填充3最小字符宽度(可选)：转换后的字符串至少应该具有该值指定的宽度。如果是，4点(.)后跟精度值(可选)：如果转换的是实数，精度值就表示出现在小数点后的位数。如果转换的是字符串，那么该数字就表示最大字段宽度。如果是，那么精度将会从元组中读出12345678&gt;&gt;&gt; &apos;%.5s&apos; % &apos;Guido van Rossum&apos; #&apos;5&apos;表示最大字段宽度&apos;Guido&apos;&gt;&gt;&gt; from math import pi&gt;&gt;&gt; &apos;%10.2f&apos; % pi #字段宽度为10，精度为2&apos; \\3.14&apos;&gt;&gt;&gt; &apos;%.*s&apos; % (5, &apos;Guido van Rossum&apos;) #使用*，表示从元组参数中读取字符宽度或者精度，这里为字符宽度为5&apos;Guido&apos; 字符串方法string 模块中’集成’了很多了方法。有用的字符串常量string.digits：包含数字0~9的字符串string.letters：包含所有字母(大写或小写)的字符串string.lowercase：包含所有小写字母的字符串string.printable：包含所用可打印字符的字符串string.punctuation：包含所有标点的字符串string.uppercase：包含所有大写字母的字符串123&gt;&gt;&gt; import string&gt;&gt;&gt; string.letters #这里使用的是2.6.6版本的Python&apos;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&apos; 字符串方法： find 可以在一个较长的字符串中查找子字符串，它返回子串所在位置的最左端索引，如果没有找到则返回-112345&gt;&gt;&gt; my_strings=&quot;This is testing&quot;&gt;&gt;&gt; my_strings.find(&apos;is&apos;)2&gt;&gt;&gt; my_strings.find(&apos;clef&apos;)-1 in操作符只能查找字符串中的单个字符。 join 是split的逆方法，被连接的序列元素必须是字符串123456789101112&gt;&gt;&gt; my_list=[1,2,3,4,5]&gt;&gt;&gt; my_string=&apos;+&apos;&gt;&gt;&gt; my_string.join(my_list) #需要添加的队列元素必须是字符串Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: sequence item 0: expected string, int found&gt;&gt;&gt; my_list=[&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;,&apos;5&apos;]&gt;&gt;&gt; my_string.join(my_list)&apos;1+2+3+4+5&apos;&gt;&gt;&gt; dirs=&apos;&apos;,&apos;usr&apos;,&apos;bin&apos;,&apos;env&apos; #这里为元组还是可以进行添加&gt;&gt;&gt; &apos;/&apos;.join(dirs)&apos;/usr/bin/env&apos; lower 返回字符串的小写12345&gt;&gt;&gt; my_strings=&quot;This&quot;&gt;&gt;&gt; my_strings.lower()&apos;this&apos;&gt;&gt;&gt; my_strings #原字符串并没有改变&apos;This&apos; replace字符串中所有匹配项均被替换之后得到的字符串12&gt;&gt;&gt; &quot;It is a testing&quot;.replace(&apos;is&apos;,&apos;replaced&apos;) #用&apos;replaced&apos;替换&apos;is&apos;&apos;It replaced a testing&apos; split将字符串分割成序列 12&apos;1+2+3+4&apos;.split(&apos;+&apos;)[&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,&apos;4&apos;] Strip返回去除字符串2侧（不包括中间）的空格，也可以指定需要去除的字符。 1234&gt;&gt;&gt; &apos; this is testing &apos;.strip() #去除了两侧的空格，并且保留了字符串内部的空格&apos;this is testing&apos;&gt;&gt;&gt; &apos;xxxthis is testing!!!xxx&apos;.strip(&apos;x!&apos;) #也可以用其他字符来代替默认的空格，这里用&apos;x&apos;或&apos;!&apos;来代替了默认的空格&apos;this is testing&apos; translate+maketrans方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。12345678910intab = &quot;aeiou&quot;outtab = &quot;12345&quot;trantab = str.maketrans(intab, outtab)str = &quot;this is string example....wow!!!&quot;print (str.translate(trantab))#输出th3s 3s str3ng 2x1mpl2....w4w!!!","categories":[],"tags":[]},{"title":"python 学习笔记1","slug":"python-学习笔记1","date":"2017-08-16T08:37:24.000Z","updated":"2017-08-16T09:03:56.000Z","comments":true,"path":"2017/08/16/python-学习笔记1/","link":"","permalink":"https://yuanleiuestc.github.io/2017/08/16/python-学习笔记1/","excerpt":"Python一种解释型的，面向对象的，带有动态语义的高级程序设计语言 第一章 基础知识1.1 基本运算符12+，-，*，/，%，//( 取整)，**（幂运算） 八进制 0o十六进制 0x长字符串用3个引号代替转义字符\\变量，语句，函数，模块等概念 2 列表和元组2.1 序列概述pythomn 最基本数据结构是序列，序列中的每个元素被分配一个序列——即元素的位置，也称为索引。第一个索引序号为0 Python中六种内建的序列 ： 列表，元祖，字符串，Unicode字符串，buffer对象.xrange对象 列表和元组的区别：列表是可以修改的，元组是不能的","text":"Python一种解释型的，面向对象的，带有动态语义的高级程序设计语言 第一章 基础知识1.1 基本运算符12+，-，*，/，%，//( 取整)，**（幂运算） 八进制 0o十六进制 0x长字符串用3个引号代替转义字符\\变量，语句，函数，模块等概念 2 列表和元组2.1 序列概述pythomn 最基本数据结构是序列，序列中的每个元素被分配一个序列——即元素的位置，也称为索引。第一个索引序号为0 Python中六种内建的序列 ： 列表，元祖，字符串，Unicode字符串，buffer对象.xrange对象 列表和元组的区别：列表是可以修改的，元组是不能的 2.2通用序列操作2.2.1索引序列中所有的元素都是有编号的–从0开始递增。可以通过编号分别对序列的元素进行访问。Python的序列也可以从右边开始索引，最右边的一个元素的索引为-1，想左开始递减。12345&gt;&gt;&gt;greeting =&apos;hello&apos;&gt;&gt;&gt;gteering[0]&apos;h&apos;&gt;&gt;&gt;gteering[-1]&apos;o&apos; 2.2.2 分片 使用分片可以访问一定范围内的元素,第一个索引的元素是包含在分片内的，第二个则不包含在分片内。1234567891011121314151617&gt;&gt;&gt; number=[1,2,3,4,5,6,7,8,9,10]&gt;&gt;&gt; number[2:4] #取索引为第二和第三的元素[3, 4]&gt;&gt;&gt; number[-4:-1] #负数表明是从右开始计数,不能到0[7, 8, 9]&gt;&gt;&gt; number[-4:] #把第二个索引置空，表明包括到序列结尾的元素[7, 8, 9, 10]&gt;&gt;&gt; number[:3] #同上，把第一个索引置空，表明包含序列开始的元素[1, 2, 3]&gt;&gt;&gt; number[0:10:1] #默认在分片的时候，步长为1,这样指定步长为1，和默认的效果一样[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&gt;&gt;&gt; number[0:10:2] #这里指定步长为2，这样就会跳过某些序列元素[1, 3, 5, 7, 9]&gt;&gt;&gt; number[10:0:-1] #步长也可以是负数，但是第一个索引一定要大于第二个索引[10, 9, 8, 7, 6, 5, 4, 3, 2]&gt;&gt;&gt; number[10:0:-2] [10, 8, 6, 4, 2] 2.2.3 序列相加使用加号运算符12345678&gt;&gt;&gt; [1,2,3]+[4,5,6][1, 2, 3, 4, 5, 6]&gt;&gt;&gt; &apos;Hello &apos;+&apos;World!&apos;&apos;Hello World!&apos;&gt;&gt;&gt; [1,2,3]+&apos;Hello&apos;Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: can only concatenate list (not &quot;str&quot;) to list 最后一个例子，试图列表和字符串进行相加，出错。两种相同类型的序列才能进行连接操作 2.2.4乘法用数字x剩以一个序列会生成新的序列，而在新的序列中，原来的序列将会被重复x次。1234&gt;&gt;&gt; &apos;python&apos;*4&apos;pythonpythonpythonpython&apos;&gt;&gt;&gt; [None]*4 #None为Python的内建值，这里创建长度为4的元素空间，但是什么元素也不包含[None, None, None, None] 2.2.5成员资格检测一个值是否存在序列当中 ，用IN运算符。 1234567891011&gt;&gt;&gt; permission=&apos;rw&apos;&gt;&gt;&gt; &apos;r&apos; in permissionTrue&gt;&gt;&gt; &apos;x&apos; in permissionFalse&gt;&gt;&gt;a =[1,2,3,4]&gt;&gt;&gt;1 in aTrue&gt;&gt;&gt; 5 in a False 2.2.6 长度，最小值，最大值len 长度max 最大值min 最小值123456789&gt;&gt;&gt; number=[2,3,4,5,6,7,8,9,10]&gt;&gt;&gt; len(number)9&gt;&gt;&gt; min(number)2&gt;&gt;&gt; max(number)10&gt;&gt;&gt; min(4,3,5) #函数的参数不用一定是序列，也可以是多个数字3 2.3 列表列表之间的元素用逗号隔开，可以存放不同的类型1a= [1,2,3,&apos;hello&apos;] 2.3.1 list函数1234&gt;&gt;&gt;list(&apos;hello&apos;)[&apos;h&apos;,&apos;e&apos;,&apos;l,&apos;l&apos;,&apos;o&apos;]&apos;&apos;.join(somelist) #将一个由字符组成的列表转换成字符串，如果既有字符也有数字会报错 2.3.2 基本的列表操作1 元素赋值123456&gt;&gt;&gt; x=[1,2,3]&gt;&gt;&gt; x[1, 2, 3]&gt;&gt;&gt; x[1]=4 #使用索引来标记某个特定位置，然后对位置明确的元素赋值&gt;&gt;&gt; x[1, 4, 3] 2 删除元素del1234&gt;&gt;&gt; name=[&apos;Clef&apos;,&apos;luo&apos;]&gt;&gt;&gt; del name[1] #直接删除列表的&apos;luo&apos;这个元素&gt;&gt;&gt; name[&apos;Clef&apos;] 3 分片赋值1234567891011121314151617181920212223242526&gt;&gt;&gt; name=list(&apos;Perl&apos;)&gt;&gt;&gt; name[&apos;P&apos;, &apos;e&apos;, &apos;r&apos;, &apos;l&apos;]&gt;&gt;&gt; name[2:]=list(&apos;ar&apos;) #对name指定序号为2和以后的进行赋值&gt;&gt;&gt; name[&apos;P&apos;, &apos;e&apos;, &apos;a&apos;, &apos;r&apos;]&gt;&gt;&gt; numbers=[1,5]&gt;&gt;&gt; numbers[1, 5]&gt;&gt;&gt; numbers[1:1]=[2,3,4] #直接插入新的列表元素&gt;&gt;&gt; numbers[1, 2, 3, 4, 5]&gt;&gt;&gt; numbers[1:4]=[] #指定删除相应的列表元素，和上面del语句效果一样的&gt;&gt;&gt; numbers[1, 5]&gt;&gt;&gt; name=list(&apos;Perl&apos;) #初始化列表name&gt;&gt;&gt; name1=name #直接赋值，表明name和name1同时引用一个列表&gt;&gt;&gt; name2=name[:] #把整个列表切片后再赋值，将会得到一个列表的副本，name2和name并不是指向同一个列表&gt;&gt;&gt; name[2]=&apos;x&apos;#修改列表name的值&gt;&gt;&gt; name[&apos;P&apos;, &apos;e&apos;, &apos;x&apos;, &apos;l&apos;]&gt;&gt;&gt; name1 #name1同时一起被修改了[&apos;P&apos;, &apos;e&apos;, &apos;x&apos;, &apos;l&apos;]&gt;&gt;&gt; name2 #但是name2并没有同时一起被修改[&apos;P&apos;, &apos;e&apos;, &apos;r&apos;, &apos;l&apos;] 2.3.2 列表的方法1.append用于在列表末尾追加新的对象1234&gt;&gt;&gt; numbers=[1,2,3]&gt;&gt;&gt; numbers.append(4) #直接追加新的列表元素&gt;&gt;&gt; numbers[1, 2, 3, 4] 2.count统计某个元素在列表中出现的次数123&gt;&gt;&gt; numbers=[1,2,1,2,3,4,2]&gt;&gt;&gt; numbers.count(2) #统计列表元素&apos;2&apos;出现的次数3 3.extend可以在列表的末尾一次性追加另一个序列中的多个值12345678&gt;&gt;&gt; a=[1,2,3]&gt;&gt;&gt; b=[4,5,6]&gt;&gt;&gt; a.extend(b)&gt;&gt;&gt; a[1, 2, 3, 4, 5, 6]也可以用分赋值实现a[len(a):]=b extend修改了原来表的结构，而直接用序列的相加则没有修改原来序列的值 4.index找出某个值第一个匹配项的索引位置1234&gt;&gt;&gt; numbers[1, 2, 1, 2, 3, 4, 2]&gt;&gt;&gt; numbers.index(2)1 5.insert将对象插入到列表当中12345&gt;&gt;&gt; numbers[1, 2, 1, 2, 3, 4, 2]&gt;&gt;&gt; numbers.insert(2,&apos;inserting&apos;) #指定序号为2的地方插入&apos;inserting&apos;&gt;&gt;&gt; numbers[1, 2, &apos;inserting&apos;, 1, 2, 3, 4, 2] 6.pop移除列表中的一个元素(默认是最后一个)，并且返回该元素的值，该方法是唯一一个既能修改列表又返回元素值(除None)的列表方法1234&gt;&gt;&gt; x=[1,2,3]&gt;&gt;&gt; x.pop()#移除最后一个元素&gt;&gt;&gt; x[1, 2] 可以和append搭配使用，实现栈的功能想实现堆的功能可以和insert搭配使用 7.remove移除列表中某个值的==第一个匹配项== 1234&gt;&gt;&gt; x=[1,2,3,2,4,5]&gt;&gt;&gt; x.remove(2) #只移除了列表中的第一个匹配到&apos;2&apos;的元素&gt;&gt;&gt; x[1, 3, 2, 4, 5] 8.reverse将列表中的元素反向存放1234&gt;&gt;&gt; x=[1,2,3,4,5]&gt;&gt;&gt; x.reverse()&gt;&gt;&gt; x[5, 4, 3, 2, 1] 该方法不返回值如果需要对有一个列表反向迭代，可以采用reversed函数123&gt;&gt;&gt;a=list(reversed(x))&gt;&gt;&gt;a[5, 4, 3, 2, 1] 9.sort对原列表进行排序，并返回空值,不返回值的方法123456&gt;&gt;&gt; x=[4,2,3,5,1]&gt;&gt;&gt; y=x.sort() #对列表x进行排序，并把返回值赋给y&gt;&gt;&gt; x #x列表已经排序[1, 2, 3, 4, 5]&gt;&gt;&gt; y #y为空，印证了上面说的，sort方法返回空值&gt;&gt;&gt; 可以将x先赋值给y1234567891011121314151617&gt;&gt;&gt; x=[4,2,3,5,1]&gt;&gt;&gt;y=x[:]&gt;&gt;&gt;y.sort()&gt;&gt;&gt;x[4,2,3,5,1]&gt;&gt;&gt;y[1, 2, 3, 4, 5]y=xy.sort&gt;&gt;&gt;x[1, 2, 3, 4, 5]&gt;&gt;&gt;y[1, 2, 3, 4, 5]#也可以直接使用sorted函数y= sorted(x) 10.高级排序key、reverse还是可以作为sort方法的参数12345678&gt;&gt;&gt; x=[&apos;abc&apos;,&apos;ab&apos;,&apos;abcd&apos;,&apos;a&apos;]&gt;&gt;&gt; x.sort(key=len) #根据元素的长度&gt;&gt;&gt; x[&apos;a&apos;, &apos;ab&apos;, &apos;abc&apos;, &apos;abcd&apos;]&gt;&gt;&gt; x=[5,2,9,7]&gt;&gt;&gt; x.sort(reverse=True) # True 方向排序&gt;&gt;&gt; x[9, 7, 5, 2] 2.4 元组 不可变序列元组：与列表一样，也是一种序列，唯一的不同就是元组不能修改。创建元组很简单，用逗号隔开一些值，就自动创建了元组，元组大部分的时候是通过圆括号括起来的。元组只有一个值的时候必须加逗号1234&gt;&gt;&gt; 3, #注意要加一个逗号，才能实现是元组(3,)&gt;&gt;&gt; () #空元组，不包含任何元素() tuple函数：功能与list函数基本上是一样的，以一个序列作为参数并把它转换为元组，如果参数是元组，那么就会原样返回该元组. 123456&gt;&gt;&gt; tuple([1,2,3]) #参数是列表，就转换为元组(1, 2, 3)&gt;&gt;&gt; tuple(&apos;abc&apos;) #与list函数用法一样(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;)&gt;&gt;&gt; tuple((&apos;a&apos;,&apos;b&apos;,&apos;c&apos;)) #参数为元组，就返回原元组，字符要加引号(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;) 元组意义 元组在映射中当作键使用，而列表不行 元组作为很多内建函数和方法的返回值，也就是说必须对元组进行处理。","categories":[],"tags":[{"name":"study","slug":"study","permalink":"https://yuanleiuestc.github.io/tags/study/"}]},{"title":"Oracle学习","slug":"Oracle","date":"2017-07-28T01:13:01.000Z","updated":"2017-08-09T07:27:44.000Z","comments":true,"path":"2017/07/28/Oracle/","link":"","permalink":"https://yuanleiuestc.github.io/2017/07/28/Oracle/","excerpt":"","text":"Oracle 学习笔记11 oracle11g 概述1.1 oracle发展历史起源于1970年《大型共享数据库的关系模型》 目前已经到oracle12g ###1.2关系数据库基本理论数据库管理技术123graph LR; 人工管理--&gt;文件管理; 文件管理--&gt;数据库系统 数据模型123graph LR;层次模型 --&gt;网状模型;网状模型--&gt; 关系模型 1.2.1 ag","categories":[],"tags":[]},{"title":"Oracle学习","slug":"Oracle学习","date":"2017-07-28T01:13:01.000Z","updated":"2017-07-28T04:12:24.000Z","comments":true,"path":"2017/07/28/Oracle学习/","link":"","permalink":"https://yuanleiuestc.github.io/2017/07/28/Oracle学习/","excerpt":"","text":"#Oracle 学习笔记 ##1 oracle11g 概述 1.1 oracle发展历史起源于1970年《大型共享数据库的关系模型》目前已经到oracle12g ###1.2关系数据库基本理论数据库管理技术123graph LR; 人工管理--&gt;文件管理; 文件管理--&gt;数据库系统 数据模型层次模型 网状模型 关系模型 名称 属性 方法 测试 name test（） 测试 name test（） graph LR; A-->B; A-->C; B-->D; C-->D;{\"theme\":\"simple\",\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);","categories":[],"tags":[]},{"title":"java学习","slug":"java学习","date":"2017-07-22T02:02:59.000Z","updated":"2017-07-28T02:19:36.000Z","comments":true,"path":"2017/07/22/java学习/","link":"","permalink":"https://yuanleiuestc.github.io/2017/07/22/java学习/","excerpt":"","text":"#数组 ##一维数组数组：一组相同数据 数组类型[] 数组名数组类类型 数据名[] example int a = new int[]{1,2,3}int a = new int[3];a[0]=1;a[1]=2;a[2]=3;int[] a ={1,2,3};下表不能为负数，从o开始，最大下标为length-1;","categories":[],"tags":[]},{"title":"统计学","slug":"统计学","date":"2017-07-21T08:20:27.000Z","updated":"2017-07-31T09:19:10.000Z","comments":true,"path":"2017/07/21/统计学/","link":"","permalink":"https://yuanleiuestc.github.io/2017/07/21/统计学/","excerpt":"","text":"11章 总体和样本的估计 进行预测内容： 如何通过样本估计总体，如何通过总体了解样本 样本估计总体样本的均值被称为总体均值的点估计量 总体的均值可以用样本的均值进行评估。不能直接用样本的方差直接估计总体的方差。因为样本的方差会小于总体的离散程度。 样本的概率估计估计总体的概率总体的估计样本的概率 如果考虑同一个总体中所有大小为n的可能样本，然后用这些样本的均值形成分布我，则该分布为“均值的抽样分布”。 12章 置信区间的构建用样本来衡量总体，如果只是采用一个点，则可能有很大的误差，采用一个置信区间的更加的合理。求解置信区间的四步骤： 选择总体估计量 求出其抽样分布 决定置信水平 求出置信上下限 当样本数目比较大时，采用正态分布，当在用小样本估计总体方差时，T分布更加准确。 上2章介绍了两钟估计总体统计量的方法。 点估计量 使用总体统计量的置信区间 第13章 假设检验的应用假设检验的六个步骤 确定要进行检验的假设 选择检验统计量 确认用于做决策的拒绝域 求出检验统计量的P值 查看样本的结果是否位于拒绝域内 作出决策 第一类错误：原假设正确却拒绝原假设 ，即检验的显著水平第二类错误：原假设错误却接受原假设 第14章 卡方分布目的：检查实际结果与期望结果之间何时存在显著差别。 卡方统计量的用途： 检验拟合优度 检验2个变量的独立性。 卡方检验的六个步骤 确定要进行检验的假设以及备选假设 求出期望频数和自由度 确认用于做决策的拒绝域 计算检验统计量卡方 查看样本的结果是否位于拒绝域内 作出决策 第15章 相关和回归之前都是对单一的变量进行分析，现在对2个变量进行相关的分析。因变量和自变量","categories":[],"tags":[]},{"title":"时间序列预测 python实现","slug":"时间序列","date":"2017-07-08T14:00:30.000Z","updated":"2017-07-21T08:15:00.000Z","comments":true,"path":"2017/07/08/时间序列/","link":"","permalink":"https://yuanleiuestc.github.io/2017/07/08/时间序列/","excerpt":"","text":"#时间序列预测 python实现使用ARIMA实现。 ##理论知识ARIMA模型全称为自回归积分滑动平均模型(Autoregressive Integrated Moving Average Model,简记ARIMA)，ARIMA(p,d,q)称为差分自回归移动平均模型AR是”自回归”，p为自回归项数；MA为”滑动平均”，q为滑动平均项数，d为使之成为平稳序列所做的差分次数（阶数） 时间序列的假设：时间序列的行为不随时间改变。。数学知识不足，去学习相关的知识。 1.首先识别时间序列的稳定性，通过散点图，自相关函数，偏相关函数判断是否平稳2.如果不是平稳的，采用d阶查分，使得序列变得稳定。？？为什么算法要求文档呢AC自相关系数 ，PAC偏相关系数 3.根据所识别的特征建立相应的时间模型，自相关函数是拖尾的（？？）采用AR模型，偏相关拖尾的，采用 MA模型，自相关函数和偏相关函数都是拖尾的，则采用 ARMA模型","categories":[],"tags":[{"name":"学习，python","slug":"学习，python","permalink":"https://yuanleiuestc.github.io/tags/学习，python/"},{"name":"ARIMA","slug":"ARIMA","permalink":"https://yuanleiuestc.github.io/tags/ARIMA/"},{"name":"时间序列","slug":"时间序列","permalink":"https://yuanleiuestc.github.io/tags/时间序列/"}]},{"title":"hexo+github 博客搭建","slug":"hexo-github-博客搭建","date":"2017-07-07T14:01:30.000Z","updated":"2017-07-28T02:19:38.000Z","comments":true,"path":"2017/07/07/hexo-github-博客搭建/","link":"","permalink":"https://yuanleiuestc.github.io/2017/07/07/hexo-github-博客搭建/","excerpt":"Hexo+github博客搭建安装软件node.js , git 网上找资料下安装Hexo(本博客采用3.0版本) 打开Git Bash,执行下面命令 npm install -g hexo-cli 如果安装失败，采用淘宝的镜像","text":"Hexo+github博客搭建安装软件node.js , git 网上找资料下安装Hexo(本博客采用3.0版本) 打开Git Bash,执行下面命令 npm install -g hexo-cli 如果安装失败，采用淘宝的镜像 npm install -g cnpm --registry=https://registry.npm.taobao.org #本地建立文件夹E:\\hexo 进入目录，右键GitBash 执行 hexo init npm install hexo g hexo s 或者hexo s -g 之后输入http://localhost:4000/就能看到博客 ， 新的博客可以在E:\\hexo\\source\\_posts增加文件，md文件。 ##注册github 创建新的仓库，仓库名字必须是：username.github.io，其中username是你的用户名； ##配置SSHKey 主要是为了安全，直接提交代码需要github的代码，不是很安全，采用机密的方式更加安全。 ssh-keygen -t rsa -C \"邮件地址\" 密钥保存在C:\\Users\\yuan\\.ssh\\id_rsa.pub 密钥添加到github 入个人设置 -> SSH and GPG keys -> New SSH key 测试是否成功 ssh -T git@github.com 在设计 git config --global user.name \"yuanleiuestc\"// 你的github用户名，非昵称 git config --global user.email \"xxx@163.com\"// 填写你的github注册 ##配置_config.yml 3.0之前 deploy: type: git repository: http://github.com/huangjunhui/huangjunhui.github.io.git branch: master 3.0，目前我用的 url: https://yuanleiuestc.github.io #你的博客地址 deploy: type: git repository: git@github.com:yuanleiuestc/yuanleiuestc.github.io.git branch: maste 创建新博客 hexo new 'my-first-blog' editor.md编辑器 npm install hexo-deployer-git –save ##发布 hexo clean hexo generate hexo d 主题下载 git clone https://github.com/litten/hexo-theme-yilia.git","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"https://yuanleiuestc.github.io/tags/学习/"}]}]}